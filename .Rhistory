<<<<<<< HEAD
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
xx<-makeCacheMatrix(1:9)
x
xx
g<-list(c("a"=1,"b"=2,"c"=3))
g
xx$setmx()
g$a
g$"a"
g<-list(c(a=1,b=2,c=3))
g
g<-list(a=1,b=2,c=3)
g
g<-list(a=1,b=2,c=3)
g
g$a
g$b
objects()
rm(makeCacheMatrix,mx,xx,invm,g)
objects()
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function(invfn)invm<<-invfn #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
rm(makeCacheMatrix)
objects()
xx<-makeCacheMatrix(1:9)
makeCacheMatrix(1:9)
objects()
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function(invfn)invm<<-invfn #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
xx<-makeCacheMatrix(1:16)
xx
xx$setmx()
xx$getmx()
xx$setmx()
xx$setmx(1:16)
z<-xx$setmx(1:16)
z
z<-xx$setmx(mx)
z
mx
xx$getmx()
xx<-makeCacheMatrix(1:16)
xx
xx$setmx(mx)
z<-xx$setmx(mx)
z
zz
xx
xx$getmx()
xx$setinvm(solve(mx))
xx<-makeCacheMatrix(1:9)
xx$getmx()
xx$setmx(mx)
xx$getmx()
xx$invm(solve(mx))
mx
xx$setinvm()
xx$setinvm(solve(mx))
xx<-makeCacheMatrix(1:4)
xx
xx$getmx()
xx$setmx()
xx$setmx(mx)
xx$getinvm()
xx$setinvm(solve(mx))
xx$getinvm()
xx<-makeCacheMatrix(1:9)
xx$getmx()
xx$setmx()
xx$setmx(mx)
xx$setinvm(solve())
xx$getinvm()
xx$setinvm()
xx$setinvm(solve(mx))
xx<-makeCacheMatrix(rnorm(1:9))
xx
xx$getmx()
xx$setmx()
xx$setmx(mx)
xx$setinvm(solve(mx))
xx$getinvm()
zz<-xx$getinvm()
v<-mx%*%zz
v
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
xx<-makeCacheMatrix(nrom(1:16))
xx<-makeCacheMatrix(rnorm(1:16))
xx
xx$getmx()
xx$setmx()
xx$setmx(mx)
xx$setinvm(xx)
xx$setinvm()
xx$getinvm()
zz<-xx$getinvm()
cc<-mx%*%zz
cc
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setmean <- function(mean) {m <<- mean}
getmean <- function() {m}
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
#print(x$get())
m <- x$getmean()
=======
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() print(mt)
setinvm <- function() invm <<- solve(mt)    #inverses mt, no need to
#functions as an argument.
#much less confusing!
getinvm <- function() invm                  #shows inversed mt
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
>>>>>>> 9c553be657eecf144c198c4527606052ccb88213
if(!is.null(m)) {
message("getting cached data")
return(m)
}
<<<<<<< HEAD
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(c(1,1,1,1,1))
makeVector(c(1,1,1,1,1))
cachemean(c(1,1,1,1,1))
c<-makeVector(c(1,1,1,1,1))
cachemean(c)
m
c$get()
c$setmean()
c$setmean(mean(c))
c$setmean(mean(c$get()))
c$getmean()
cachemean(c)
d<-makeVector(c(2,2,2))
cachemean(d)
cachemean(c)
e<-makeVector(c(1,1,1,1,1))
cachemean(e)
cachemean(c)
j<-cachemean(c(2,2,2))
j<-makeVector(c(2,2,2))
cachemean(j)
makeVector(c(3,3,3))
cachemean(c(3,3,3))
cachemean(3,3,3)
h<-c(4,4,4)
makeVector(h)
cachemean(h)
m
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invmm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(m)
invm
}
ma<-makeCacheMatrix(rnorm(1:25))
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invmm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(m)
invm
}
a$getmx()
ma$getmx()
ma$setinvm()
ma$getinvm()
cachesolve(ma)
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invmm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(m)
invm
}
ma$getinvm()
cacheSolve(ma)
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(m)
invm
}
cacheSolve(ma)
mb<-makeCacheMatrix(rnorm(1:36))
mb$getmx()
cacheSolve(mb)
cacheSolve(solve(mb))
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(invm)
invm
}
cacheSolve(mb)
objects()
rm(c,d,cachemean,cacheSolve,cc,h,e,makeCacheMatrix,makeVector,mb,mx,z,xx,v,submit,zz,ma)
objects(0)
objects()
rm(invm,j)
objects()
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(invm)
invm
}
a<-makeCacheMatrix(rnorm(1:9))
a
a$getmx()
cacheSolve(a)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setmean <- function(mean) {m <<- mean}
getmean <- function() {m}
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
#print(x$get())
m <- x$getmean()
=======
data <- x$getmat()
m <- mean(data, ...)
x$setinvm(m)
m
}
cacheSolve(mat)
mel <- makeCacheMatrix(1:9)
mel <- makeCacheMatrix(rnorm(1:9))
cacheSolve(mel)
cacheSolve(mel)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
cacheSolve(mel)
mel$getinvm()
cacheSolve(mat)
mat$getinvm()
mel$getinvm()
o  <- objects
rm(o)
objects()
rm(o)
rm(*)
ls
ls
ma <- makeCacheMatrix(rnorm(1:25))
mb <- makeCacheMatrix(rnorm(1:49))
ma$setinvm()
ma$getinvm
ma$getinvm()
mb$getinvm()
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() print(mt)
setinvm <- function() invm <<- solve(mt)    #inverses mt, no need to
#functions as an argument.
#much less confusing!
getinvm <- function() invm                  #shows inversed mt
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
ma <- makeCacheMatrix(rnorm(1:25))
ma$getmat()
ma$getxvalues()
ma$setinvm()
ma$getmat
ma$getmat()
ma$getinvm()
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() print(mt)
setinvm <- function(solve) invm <<- solve    #inverses mt, no need to
#functions as an argument.
#much less confusing!
getinvm <- function() invm                  #shows inversed mt
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
ma$setinvm(solve(ma$getmat()))
ma$getmat()
source(ma$getmat)
source(ma$getmat())
ma <- makeCacheMatrix(1:9)
ma
ma$getmat()
ma$setinv(solve(ma$getmat))
ma <- makeCacheMatrix(1:25)
ma <- makeCacheMatrix(1:9)
source(ma)
source(ma$getmat())
ma <- makeCacheMatrix(rnorm(1:9''))
ma <- makeCacheMatrix(rnorm(1:9)
)
source(ma$getmat())
ma$getmat()
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() return(mt)
setinvm <- function(solve) invm <<- solve
getinvm <- function() invm
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
ma$getmat()
ma$setinv(source(ma$getmat()))
ma$getmat
ma$getmat()
solve(ma$getmat)
solve(ma$getmat())
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() return(mt)
setinvm <- function() invm <<- solve(mt)
getinvm <- function() invm
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
solve(ma$getmat())
solve(ma$getmat())
rm(ma)
objects
objects()
rm(mb)
dir
ls
ma <- makeCacheMatrix(rnorm(1:25))
mb <- makeCacheMatrix(rnorm(1:49))
ma$getmat()
ma$setinvm()
ma$getinvm()
mb$setinvm()
mb$getmat()
mb$getinvm()
cacheSolve(ma$getmat())
cacheSolve(rnorm(1:25)
)
rm(ma)
ma <- makeCacheMatrix(rnorm(1:25))
ma$getmat()
ma$getinv()
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
invm <- NULL
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() return(mt)
setinvm <- function() invm <<- solve(mt)
getinvm <- function() invm
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
>>>>>>> 9c553be657eecf144c198c4527606052ccb88213
if(!is.null(m)) {
message("getting cached data")
return(m)
}
<<<<<<< HEAD
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
a<-makeVector(c(1,1,1,1,1))
b<-makeVector(c(2,2,2,2))
a$get()
b$get()
a$setmean(mean(a))
a$setmean(mean(a$get()))
a$getmean()
b$getmean()
cachemean(a)
cachemean(b)
d<-makeVector(c(4,4,4))
b$setmean(mean(b$get()))
cachemean(b)
cachemean(a)
a$list
a
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(invm)
invm
}
satu<-makeCacheMatrix(rnorm(1:4))
dua<-makeCacheMatrix(rnorm(4:8))
dua<-makeCacheMatrix(rnorm(1:9))
dua$get()
dua$getmx()
satu$getmx()
cacheSolve(dua)
=======
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
rm(ma)
ma <- makeCacheMatrix(rnorm(1:25))
ma$getmat()
ma$getinvm()
mb$getinvm()
ma$getinvm()
rm(ma)
rm(mb)
ma <- makeCacheMatrix(rnorm(1:25))
mb <- makeCacheMatrix(rnorm(1:49))
ma$getmat()
mb$setinvm()
mb$getinvm()
mb$getmat()
ma$getinvm()
ma$setinvm()
ma$getinvm()
mb$getinvm()
cacheSolve(ma$getmat())
cacheSolve(ma)
rm(mb)
mb <- makeCacheMatrix(rnorm(1:49))
cacheSolve(mb)
mb$setinvm()
cacheSolve(mb)
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
invm <- NULL                      #This is required to prevent a previously defined
#invm from returning and falsey being reported
#as the inversion of our current matrix.
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() return(mt)
setinvm <- function(matvalue) invm <<- solve(matvalue)
getinvm <- function() invm
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
rm(mb)
mb <- makeCacheMatrix(rnorm(1:24))
mb <- makeCacheMatrix(rnorm(1:24))
mb <- makeCacheMatrix(rnorm(1:25))
mb$setinvm()
mb$setinvm(mb$getmat())
mb$getinvm()
cacheSolve(mb$getmat())
mb
cacheSolve(mb)
cacheSolve(ma)
ma
cacheSolve(ma)
ma
cacheSolve(mb)
mc <- makeCacheMatrix(rnorm(1:10))
mc <- makeCacheMatrix(rnorm(1:12))
mc <- makeCacheMatrix(rnorm(1:16))
cachesolv(mc)
cacheSolve(mc)
cacheSolve(mc)
>>>>>>> 9c553be657eecf144c198c4527606052ccb88213
