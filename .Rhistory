list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
xx<-makeCacheMatrix(1:9)
x
xx
g<-list(c("a"=1,"b"=2,"c"=3))
g
xx$setmx()
g$a
g$"a"
g<-list(c(a=1,b=2,c=3))
g
g<-list(a=1,b=2,c=3)
g
g<-list(a=1,b=2,c=3)
g
g$a
g$b
objects()
rm(makeCacheMatrix,mx,xx,invm,g)
objects()
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function(invfn)invm<<-invfn #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
rm(makeCacheMatrix)
objects()
xx<-makeCacheMatrix(1:9)
makeCacheMatrix(1:9)
objects()
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function(invfn)invm<<-invfn #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
xx<-makeCacheMatrix(1:16)
xx
xx$setmx()
xx$getmx()
xx$setmx()
xx$setmx(1:16)
z<-xx$setmx(1:16)
z
z<-xx$setmx(mx)
z
mx
xx$getmx()
xx<-makeCacheMatrix(1:16)
xx
xx$setmx(mx)
z<-xx$setmx(mx)
z
zz
xx
xx$getmx()
xx$setinvm(solve(mx))
xx<-makeCacheMatrix(1:9)
xx$getmx()
xx$setmx(mx)
xx$getmx()
xx$invm(solve(mx))
mx
xx$setinvm()
xx$setinvm(solve(mx))
xx<-makeCacheMatrix(1:4)
xx
xx$getmx()
xx$setmx()
xx$setmx(mx)
xx$getinvm()
xx$setinvm(solve(mx))
xx$getinvm()
xx<-makeCacheMatrix(1:9)
xx$getmx()
xx$setmx()
xx$setmx(mx)
xx$setinvm(solve())
xx$getinvm()
xx$setinvm()
xx$setinvm(solve(mx))
xx<-makeCacheMatrix(rnorm(1:9))
xx
xx$getmx()
xx$setmx()
xx$setmx(mx)
xx$setinvm(solve(mx))
xx$getinvm()
zz<-xx$getinvm()
v<-mx%*%zz
v
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
xx<-makeCacheMatrix(nrom(1:16))
xx<-makeCacheMatrix(rnorm(1:16))
xx
xx$getmx()
xx$setmx()
xx$setmx(mx)
xx$setinvm(xx)
xx$setinvm()
xx$getinvm()
zz<-xx$getinvm()
cc<-mx%*%zz
cc
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setmean <- function(mean) {m <<- mean}
getmean <- function() {m}
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
#print(x$get())
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(c(1,1,1,1,1))
makeVector(c(1,1,1,1,1))
cachemean(c(1,1,1,1,1))
c<-makeVector(c(1,1,1,1,1))
cachemean(c)
m
c$get()
c$setmean()
c$setmean(mean(c))
c$setmean(mean(c$get()))
c$getmean()
cachemean(c)
d<-makeVector(c(2,2,2))
cachemean(d)
cachemean(c)
e<-makeVector(c(1,1,1,1,1))
cachemean(e)
cachemean(c)
j<-cachemean(c(2,2,2))
j<-makeVector(c(2,2,2))
cachemean(j)
makeVector(c(3,3,3))
cachemean(c(3,3,3))
cachemean(3,3,3)
h<-c(4,4,4)
makeVector(h)
cachemean(h)
m
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invmm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(m)
invm
}
ma<-makeCacheMatrix(rnorm(1:25))
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invmm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(m)
invm
}
a$getmx()
ma$getmx()
ma$setinvm()
ma$getinvm()
cachesolve(ma)
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invmm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(m)
invm
}
ma$getinvm()
cacheSolve(ma)
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(m)
invm
}
cacheSolve(ma)
mb<-makeCacheMatrix(rnorm(1:36))
mb$getmx()
cacheSolve(mb)
cacheSolve(solve(mb))
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(invm)
invm
}
cacheSolve(mb)
objects()
rm(c,d,cachemean,cacheSolve,cc,h,e,makeCacheMatrix,makeVector,mb,mx,z,xx,v,submit,zz,ma)
objects(0)
objects()
rm(invm,j)
objects()
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(invm)
invm
}
a<-makeCacheMatrix(rnorm(1:9))
a
a$getmx()
cacheSolve(a)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setmean <- function(mean) {m <<- mean}
getmean <- function() {m}
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
#print(x$get())
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
a<-makeVector(c(1,1,1,1,1))
b<-makeVector(c(2,2,2,2))
a$get()
b$get()
a$setmean(mean(a))
a$setmean(mean(a$get()))
a$getmean()
b$getmean()
cachemean(a)
cachemean(b)
d<-makeVector(c(4,4,4))
b$setmean(mean(b$get()))
cachemean(b)
cachemean(a)
a$list
a
makeCacheMatrix <- function(x = matrix()) {
l<-length(x)   #return the length of x
numrow=sqrt(l) #square root of length of matrix values, to be used as nrow parameter
numcol=sqrt(l) #square root of length of matrix values, to be used as ncol parameter
mod=sqrt(l)%%1 #calculate modulus of the length of matrix values (if it's 0 or not)
if (mod!=0){print("Error:square matrix can not be created with the length of the values")}
#if mod is not 0, inform user the value supplied can not be converted to a square matrix
else {
invm<<-NULL
mx<<-matrix(x,numrow,numcol) #if mod is 0 then go ahead and create
setmx<-function(y){mx<<-y    #a matrix called mx
invm<<-NULL}
getmx<-function()mx
setinvm<-function()invm<<-solve(mx) #investigate this............
getinvm<-function()invm
list(setmx = setmx, getmx = getmx,
setinvm = setinvm,
getinvm = getinvm)
}
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
invm <- x$getinvm()
if(!is.null(invm)) {
message("getting cached data")
return(invm)
}
data <- x$getmx()
invmm <- solve(data, ...)
x$setinvm(invm)
invm
}
satu<-makeCacheMatrix(rnorm(1:4))
dua<-makeCacheMatrix(rnorm(4:8))
dua<-makeCacheMatrix(rnorm(1:9))
dua$get()
dua$getmx()
satu$getmx()
cacheSolve(dua)
