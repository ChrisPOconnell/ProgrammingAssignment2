xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() print(mt)
setinvm <- function() invm <<- solve(mt)    #inverses mt, no need to
#functions as an argument.
#much less confusing!
getinvm <- function() invm                  #shows inversed mt
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- mean(data, ...)
x$setinvm(m)
m
}
cacheSolve(mat)
mel <- makeCacheMatrix(1:9)
mel <- makeCacheMatrix(rnorm(1:9))
cacheSolve(mel)
cacheSolve(mel)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
cacheSolve(mel)
mel$getinvm()
cacheSolve(mat)
mat$getinvm()
mel$getinvm()
o  <- objects
rm(o)
objects()
rm(o)
rm(*)
ls
ls
ma <- makeCacheMatrix(rnorm(1:25))
mb <- makeCacheMatrix(rnorm(1:49))
ma$setinvm()
ma$getinvm
ma$getinvm()
mb$getinvm()
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() print(mt)
setinvm <- function() invm <<- solve(mt)    #inverses mt, no need to
#functions as an argument.
#much less confusing!
getinvm <- function() invm                  #shows inversed mt
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
ma <- makeCacheMatrix(rnorm(1:25))
ma$getmat()
ma$getxvalues()
ma$setinvm()
ma$getmat
ma$getmat()
ma$getinvm()
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() print(mt)
setinvm <- function(solve) invm <<- solve    #inverses mt, no need to
#functions as an argument.
#much less confusing!
getinvm <- function() invm                  #shows inversed mt
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
ma$setinvm(solve(ma$getmat()))
ma$getmat()
source(ma$getmat)
source(ma$getmat())
ma <- makeCacheMatrix(1:9)
ma
ma$getmat()
ma$setinv(solve(ma$getmat))
ma <- makeCacheMatrix(1:25)
ma <- makeCacheMatrix(1:9)
source(ma)
source(ma$getmat())
ma <- makeCacheMatrix(rnorm(1:9''))
ma <- makeCacheMatrix(rnorm(1:9)
)
source(ma$getmat())
ma$getmat()
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() return(mt)
setinvm <- function(solve) invm <<- solve
getinvm <- function() invm
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
ma$getmat()
ma$setinv(source(ma$getmat()))
ma$getmat
ma$getmat()
solve(ma$getmat)
solve(ma$getmat())
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() return(mt)
setinvm <- function() invm <<- solve(mt)
getinvm <- function() invm
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
solve(ma$getmat())
solve(ma$getmat())
rm(ma)
objects
objects()
rm(mb)
dir
ls
ma <- makeCacheMatrix(rnorm(1:25))
mb <- makeCacheMatrix(rnorm(1:49))
ma$getmat()
ma$setinvm()
ma$getinvm()
mb$setinvm()
mb$getmat()
mb$getinvm()
cacheSolve(ma$getmat())
cacheSolve(rnorm(1:25)
)
rm(ma)
ma <- makeCacheMatrix(rnorm(1:25))
ma$getmat()
ma$getinv()
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
invm <- NULL
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() return(mt)
setinvm <- function() invm <<- solve(mt)
getinvm <- function() invm
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
rm(ma)
ma <- makeCacheMatrix(rnorm(1:25))
ma$getmat()
ma$getinvm()
mb$getinvm()
ma$getinvm()
rm(ma)
rm(mb)
ma <- makeCacheMatrix(rnorm(1:25))
mb <- makeCacheMatrix(rnorm(1:49))
ma$getmat()
mb$setinvm()
mb$getinvm()
mb$getmat()
ma$getinvm()
ma$setinvm()
ma$getinvm()
mb$getinvm()
cacheSolve(ma$getmat())
cacheSolve(ma)
rm(mb)
mb <- makeCacheMatrix(rnorm(1:49))
cacheSolve(mb)
mb$setinvm()
cacheSolve(mb)
##Chris P. OConnell
##8/20/2015
##I've made the makeCacheMatrix really nice for you.
##No need to send any complicated argument in.  Just
##type in the numbers you want in the matrix.
##I'll check to see if the matrix can be square.
##If the numbers can't create a square matrix I'll
##let you know.
##example:  mat <- makeCacheMatrix(1:100)
##In this case I will create a nice 10x10 matrix for you.
makeCacheMatrix <- function(x = matrix()) {
invm <- NULL                      #This is required to prevent a previously defined
#invm from returning and falsey being reported
#as the inversion of our current matrix.
len <- length(x)                  #Determines length of x.
#Used for two things:
#1st, determine if matrix can be square
#2nd, create  sq
sq <- sqrt(len)
mod <- sqrt(len) %% 1              #This determines if the matrix can be square
if (mod!=0){
print("Sorry, the values you provided can't create a square matrix.")
}
else {
#if (mod == 0 && len!=0) { #If matrix can be square, enter perform if statement.
mt<- matrix(x,nrow=sq,ncol=sq) #using the square root of the values you provide
#a square matrix
xvalues<<-x
#print("Congrats, your thingy is created")
getmat <- function() return(mt)
setinvm <- function(matvalue) invm <<- solve(matvalue)
getinvm <- function() invm
getxvalues <- function() print(xvalues)
}
#  I wasn't able to get this function working, but was attempting to
#  create a function
multiplymatrixes <- function() {
mni <- getmat()
mi <- getinvm()
mi %*% mni
}
list(setinvm = setinvm,
getmat = getmat,
getinvm = getinvm,
getxvalues = getxvalues,
multiplymatrixes = multiplymatrixes)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvm()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$getmat()
m <- solve(data)
x$setinvm(m)
m
}
rm(mb)
mb <- makeCacheMatrix(rnorm(1:24))
mb <- makeCacheMatrix(rnorm(1:24))
mb <- makeCacheMatrix(rnorm(1:25))
mb$setinvm()
mb$setinvm(mb$getmat())
mb$getinvm()
cacheSolve(mb$getmat())
mb
cacheSolve(mb)
cacheSolve(ma)
ma
cacheSolve(ma)
ma
cacheSolve(mb)
mc <- makeCacheMatrix(rnorm(1:10))
mc <- makeCacheMatrix(rnorm(1:12))
mc <- makeCacheMatrix(rnorm(1:16))
cachesolv(mc)
cacheSolve(mc)
cacheSolve(mc)
